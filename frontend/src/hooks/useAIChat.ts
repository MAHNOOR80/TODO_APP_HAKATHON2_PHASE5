import { useState, useCallback } from 'react';
import {
  AIChatMessage,
  AIChatRequest,
} from '../types/ai.types';
import { aiApiService as aiApi } from '../services/ai.api';
import { useNotifications } from './useNotifications';

interface UseAIChatReturn {
  messages: AIChatMessage[];
  sendMessage: (message: string) => Promise<void>;
  isLoading: boolean;
  requiresConfirmation: boolean;
  handleConfirmation: (confirmed: boolean) => Promise<void>;
  sessionId: string | null;
}

export const useAIChat = (onTasksUpdated?: () => void): UseAIChatReturn => {
  const { permission, requestPermission, showNotification, isSupported } = useNotifications();
  const [messages, setMessages] = useState<AIChatMessage[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [requiresConfirmation, setRequiresConfirmation] = useState(false);
  const [pendingAction, setPendingAction] = useState<any>(null);

  // Function to execute action plans generated by the AI
  const executeActionPlans = useCallback(async (actionPlans: any[]) => {
    for (const plan of actionPlans) {
      try {
        if (plan.operation && plan.endpoint && plan.method) {
          // Make the API call based on the action plan
          const apiUrl = `${import.meta.env.VITE_API_URL || 'http://localhost:5006/api/v1'}${plan.endpoint}`;
          
          console.log(`[Exec] Auto-executing action: ${plan.method} ${plan.endpoint}`);

          const response = await fetch(apiUrl, {
            method: plan.method,
            headers: {
              'Content-Type': 'application/json',
            },
            body: plan.payload ? JSON.stringify(plan.payload) : undefined,
            credentials: 'include' // Ensure session cookies are included
          });

          if (!response.ok) {
            console.error(`Failed to execute action plan: ${plan.operation}`, await response.text());
          } else {
            console.log(`Successfully executed action plan: ${plan.operation}`);

            // Notify parent component that tasks may have been updated
            if (onTasksUpdated) {
              onTasksUpdated();
            }
          }
        }
      } catch (error) {
        console.error('Error executing action plan:', error);
      }
    }
  }, [onTasksUpdated]);

  // Function to handle sending messages to the AI
  const sendMessage = useCallback(async (message: string) => {
    if (isLoading) return;

    setIsLoading(true);
    setRequiresConfirmation(false);

    try {
      // Check if the message contains notification-related commands
      const lowerCaseMessage = message.toLowerCase();
      if (lowerCaseMessage.includes('enable reminders') || lowerCaseMessage.includes('enable notifications')) {
        // Add user message to the chat
        const userMessage: AIChatMessage = {
          id: Date.now().toString(),
          content: message,
          role: 'user',
          timestamp: new Date().toISOString()
        };

        setMessages(prev => [...prev, userMessage]);

        // Handle notification permission request
        if (!isSupported) {
          const errorMessage: AIChatMessage = {
            id: (Date.now() + 1).toString(),
            content: 'Browser notifications are not supported in your browser.',
            role: 'assistant',
            timestamp: new Date().toISOString()
          };

          setMessages(prev => [...prev, errorMessage]);
        } else {
          try {
            const result = await requestPermission();
            if (result === 'granted') {
              // Add success message to the chat
              const successMessage: AIChatMessage = {
                id: (Date.now() + 1).toString(),
                content: 'Browser notifications enabled successfully! You will now receive task reminders and due date notifications.',
                role: 'assistant',
                timestamp: new Date().toISOString()
              };

              setMessages(prev => [...prev, successMessage]);

              // Show a test notification to confirm it's working
              showNotification('Notifications Enabled', {
                body: 'You will now receive task reminders and due date notifications',
                icon: '/favicon.ico',
                tag: 'notification-enabled',
              });
            } else if (result === 'denied') {
              const deniedMessage: AIChatMessage = {
                id: (Date.now() + 1).toString(),
                content: 'Notifications were blocked. Please enable them in your browser settings.',
                role: 'assistant',
                timestamp: new Date().toISOString()
              };

              setMessages(prev => [...prev, deniedMessage]);
            } else {
              const defaultMessage: AIChatMessage = {
                id: (Date.now() + 1).toString(),
                content: 'Notification permissions were not granted. Please allow notifications to receive task reminders.',
                role: 'assistant',
                timestamp: new Date().toISOString()
              };

              setMessages(prev => [...prev, defaultMessage]);
            }
          } catch (err) {
            const errorMessage: AIChatMessage = {
              id: (Date.now() + 1).toString(),
              content: 'Failed to enable notifications. Please try again.',
              role: 'assistant',
              timestamp: new Date().toISOString()
            };

            setMessages(prev => [...prev, errorMessage]);
          }
        }
      } else {
        // Add user message to the chat
        const userMessage: AIChatMessage = {
          id: Date.now().toString(),
          content: message,
          role: 'user',
          timestamp: new Date().toISOString()
        };

        setMessages(prev => [...prev, userMessage]);

        // Prepare the AI request
        const aiRequest: AIChatRequest = {
          message,
        };

        // Send the request to the AI API
        const response = await aiApi.chat(aiRequest);

        // Handle the AI response
        if (response.success && response.data) {
          const aiMessage: AIChatMessage = {
            id: (Date.now() + 1).toString(),
            content: response.data.responseText,
            role: 'assistant',
            timestamp: new Date().toISOString(),
            // Force confirmation to false in the UI message
            requiresConfirmation: false,
            actionPlan: response.data.actionPlan
          };

          setMessages(prev => [...prev, aiMessage]);

          // --- KEY CHANGE: AUTO-EXECUTE INSTEAD OF ASKING ---
          if (response.data.actionPlan && response.data.actionPlan.length > 0) {
             // Direct execution, skipping setRequiresConfirmation(true)
             await executeActionPlans(response.data.actionPlan);
          }
        } else {
          // Add error message to the chat
          const errorMessage: AIChatMessage = {
            id: (Date.now() + 1).toString(),
            content: response.error?.message || 'Unknown error occurred',
            role: 'assistant',
            timestamp: new Date().toISOString()
          };

          setMessages(prev => [...prev, errorMessage]);
        }
      }
    } catch (error) {
      console.error('Error sending message:', error);

      // Add error message to the chat
      const errorMessage: AIChatMessage = {
        id: (Date.now() + 1).toString(),
        content: 'Sorry, I encountered an error processing your request.',
        role: 'assistant',
        timestamp: new Date().toISOString()
      };

      setMessages(prev => [...prev, errorMessage]);
    } finally {
      setIsLoading(false);
    }
  }, [isLoading, executeActionPlans, isSupported, requestPermission, showNotification]); // Added executeActionPlans to dependencies

  // Function to handle confirmation of action plans
  // (Kept for compatibility, but largely bypassed now)
  const handleConfirmation = useCallback(async (confirmed: boolean) => {
    if (!confirmed || !pendingAction) {
      setRequiresConfirmation(false);
      setPendingAction(null);
      return;
    }

    // Execute the confirmed action plans
    await executeActionPlans(pendingAction);

    setRequiresConfirmation(false);
    setPendingAction(null);
  }, [pendingAction, executeActionPlans]);

  return {
    messages,
    sendMessage,
    isLoading,
    requiresConfirmation,
    handleConfirmation,
    sessionId: null
  };
};